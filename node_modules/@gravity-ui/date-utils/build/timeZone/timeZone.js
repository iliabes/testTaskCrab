"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fixOffset = exports.normalizeTimeZone = exports.timeZoneOffset = exports.isValidTimeZone = exports.getTimeZonesList = exports.guessUserTimeZone = void 0;
var constants_1 = require("../constants");
var dayjs_1 = __importDefault(require("../dayjs"));
/**
 * Returns the user's time zone.
 */
var guessUserTimeZone = function () { return dayjs_1.default.tz.guess(); };
exports.guessUserTimeZone = guessUserTimeZone;
/**
 * Returns all time zones.
 */
// remove when Intl definition is extended
// @ts-expect-error https://github.com/microsoft/TypeScript/issues/49231
var getTimeZonesList = function () { var _a; return ((_a = Intl.supportedValuesOf) === null || _a === void 0 ? void 0 : _a.call(Intl, 'timeZone')) || []; };
exports.getTimeZonesList = getTimeZonesList;
var validTimeZones = {};
function isValidTimeZone(zone) {
    if (!zone) {
        return false;
    }
    if (Object.prototype.hasOwnProperty.call(validTimeZones, zone)) {
        return validTimeZones[zone];
    }
    try {
        new Intl.DateTimeFormat('en-US', { timeZone: zone }).format();
        validTimeZones[zone] = true;
        return true;
    }
    catch (_a) {
        validTimeZones[zone] = false;
        return false;
    }
}
exports.isValidTimeZone = isValidTimeZone;
var dateTimeFormatCache = {};
function makeDateTimeFormat(zone) {
    if (!dateTimeFormatCache[zone]) {
        dateTimeFormatCache[zone] = new Intl.DateTimeFormat('en-US', {
            hour12: false,
            timeZone: zone === 'system' ? undefined : zone,
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            era: 'short',
        });
    }
    return dateTimeFormatCache[zone];
}
var dateFields = [
    'year',
    'month',
    'day',
    'hour',
    'minute',
    'second',
    'era',
];
function isDateField(v) {
    return dateFields.includes(v);
}
function timeZoneOffset(zone, ts) {
    var date = new Date(ts);
    if (isNaN(date.valueOf()) || (zone !== 'system' && !isValidTimeZone(zone))) {
        return NaN;
    }
    if (zone === 'system') {
        return -date.getTimezoneOffset();
    }
    var dtf = makeDateTimeFormat(zone);
    var formatted = dtf.formatToParts(date);
    var parts = {
        year: 1,
        month: 1,
        day: 1,
        hour: 0,
        minute: 0,
        second: 0,
        era: 'AD',
    };
    for (var _i = 0, formatted_1 = formatted; _i < formatted_1.length; _i++) {
        var _a = formatted_1[_i], type = _a.type, value = _a.value;
        if (type === 'era') {
            parts.era = value;
        }
        else if (isDateField(type)) {
            parts[type] = parseInt(value, 10);
        }
    }
    // Date.UTC(year), year: 0 — is 1 BC, -1 — is 2 BC, e.t.c
    var year = parts.era === 'BC' ? -Math.abs(parts.year) + 1 : parts.year;
    var month = parts.month - 1; // month is zero base index
    // https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat
    var hour = parts.hour === 24 ? 0 : parts.hour;
    var asUTC = Date.UTC(year, month, parts.day, hour, parts.minute, parts.second, 0);
    // years between 0 and 99 are interpreted as 19XX; revert that
    if (year < 100 && year >= 0) {
        var d = new Date(asUTC);
        d.setUTCFullYear(year, month, parts.day);
        asUTC = d.valueOf();
    }
    var asTS = date.valueOf();
    var over = asTS % 1000;
    asTS -= over >= 0 ? over : 1000 + over;
    return (asUTC - asTS) / (60 * 1000);
}
exports.timeZoneOffset = timeZoneOffset;
function normalizeTimeZone(input, defaultZone) {
    if (input === undefined || input === null) {
        return defaultZone;
    }
    var lowered = input.toLowerCase();
    if (lowered === 'utc' || lowered === 'gmt') {
        return constants_1.UtcTimeZone;
    }
    if (lowered === 'system') {
        return 'system';
    }
    if (lowered === 'default') {
        return defaultZone;
    }
    if (isValidTimeZone(input)) {
        return input;
    }
    throw new Error("InvalidZone: ".concat(input));
}
exports.normalizeTimeZone = normalizeTimeZone;
function fixOffset(localTS, o, tz) {
    // Our UTC time is just a guess because our offset is just a guess
    var utcGuess = localTS - o * 60 * 1000;
    // Test whether the zone matches the offset for this ts
    var o2 = timeZoneOffset(tz, utcGuess);
    // If so, offset didn't change and we're done
    if (o === o2) {
        return [utcGuess, o];
    }
    // If not, change the ts by the difference in the offset
    utcGuess -= (o2 - o) * 60 * 1000;
    // If that gives us the local time we want, we're done
    var o3 = timeZoneOffset(tz, utcGuess);
    if (o2 === o3) {
        return [utcGuess, o2];
    }
    // If it's different, we're in a hole time. The offset has changed, but we don't adjust the time
    return [localTS - Math.min(o2, o3) * 60 * 1000, Math.min(o2, o3)];
}
exports.fixOffset = fixOffset;
