"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.offsetFromString = exports.normalizeDateComponents = exports.normalizeComponent = exports.objToTS = exports.tsToObject = exports.daysInMonth = exports.isLeapYear = exports.floorMod = void 0;
// x % n but takes the sign of n instead of x
function floorMod(x, n) {
    return x - n * Math.floor(x / n);
}
exports.floorMod = floorMod;
function isLeapYear(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
exports.isLeapYear = isLeapYear;
function daysInMonth(year, month) {
    var modMonth = floorMod(month, 12), modYear = year + (month - modMonth) / 12;
    if (modMonth === 1) {
        return isLeapYear(modYear) ? 29 : 28;
    }
    else {
        return [31, -1, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth];
    }
}
exports.daysInMonth = daysInMonth;
function tsToObject(ts, offset) {
    var value = ts + offset * 60 * 1000;
    var date = new Date(value);
    return {
        year: date.getUTCFullYear(),
        month: date.getUTCMonth(),
        date: date.getUTCDate(),
        hour: date.getUTCHours(),
        minute: date.getUTCMinutes(),
        second: date.getUTCSeconds(),
        millisecond: date.getUTCMilliseconds(),
    };
}
exports.tsToObject = tsToObject;
function objToTS(obj) {
    var ts = Date.UTC(obj.year, obj.month, obj.date, obj.hour, obj.minute, obj.second, obj.millisecond);
    // for legacy reasons, years between 0 and 99 are interpreted as 19XX; revert that
    if (obj.year < 100 && obj.year >= 0) {
        var d = new Date(ts);
        // set the month and day again, this is necessary because year 2000 is a leap year, but year 100 is not
        // so if obj.year is in 99, but obj.day makes it roll over into year 100,
        // the calculations done by Date.UTC are using year 2000 - which is incorrect
        d.setUTCFullYear(obj.year, obj.month, obj.date);
        return d.valueOf();
    }
    return ts;
}
exports.objToTS = objToTS;
var normalizedUnits = {
    y: 'year',
    year: 'year',
    years: 'year',
    M: 'month',
    month: 'month',
    months: 'month',
    D: 'date',
    date: 'date',
    dates: 'date',
    h: 'hour',
    hour: 'hour',
    hours: 'hour',
    m: 'minute',
    minute: 'minute',
    minutes: 'minute',
    Q: 'quarter',
    quarter: 'quarter',
    quarters: 'quarter',
    s: 'second',
    second: 'second',
    seconds: 'second',
    ms: 'millisecond',
    millisecond: 'millisecond',
    milliseconds: 'millisecond',
    d: 'day',
    day: 'day',
    days: 'day',
    weeknumber: 'weekNumber',
    w: 'weekNumber',
    week: 'weekNumber',
    weeks: 'weekNumber',
    isoweeknumber: 'isoWeekNumber',
    W: 'isoWeekNumber',
    isoweek: 'isoWeekNumber',
    isoweeks: 'isoWeekNumber',
    E: 'isoWeekday',
    isoweekday: 'isoWeekday',
    isoweekdays: 'isoWeekday',
    weekday: 'day',
    weekdays: 'day',
    e: 'day',
};
function normalizeComponent(component) {
    var unit = ['d', 'D', 'm', 'M', 'w', 'W', 'E', 'Q'].includes(component)
        ? component
        : component.toLowerCase();
    if (unit in normalizedUnits) {
        return normalizedUnits[unit];
    }
    throw new Error("Invalid unit ".concat(component));
}
exports.normalizeComponent = normalizeComponent;
function asNumber(value) {
    var numericValue = Number(value);
    if (typeof value === 'boolean' || value === '' || Number.isNaN(numericValue)) {
        throw new Error("Invalid unit value ".concat(value));
    }
    return numericValue;
}
function normalizeDateComponents(components) {
    var normalized = {};
    for (var _i = 0, _a = Object.entries(components); _i < _a.length; _i++) {
        var _b = _a[_i], c = _b[0], v = _b[1];
        if (v === undefined || v === null)
            continue;
        normalized[normalizeComponent(c)] = asNumber(v);
    }
    return normalized;
}
exports.normalizeDateComponents = normalizeDateComponents;
var matchOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z
// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset = /([+-]|\d\d)/gi;
function offsetFromString(value) {
    var matches = (value || '').match(matchOffset);
    if (matches === null) {
        return null;
    }
    var chunk = matches[matches.length - 1] || '';
    var _a = String(chunk).match(chunkOffset) || ['-', 0, 0], sign = _a[0], h = _a[1], m = _a[2];
    var minutes = Number(Number(h) * 60) + (isFinite(Number(m)) ? Number(m) : 0);
    return sign === '+' ? minutes : -minutes;
}
exports.offsetFromString = offsetFromString;
